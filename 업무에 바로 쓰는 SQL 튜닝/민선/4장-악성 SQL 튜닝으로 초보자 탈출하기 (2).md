# 4장 악성 SQL 튜닝으로 초보자 탈출하기

<br>

### 4.2.6 다수 쿼리를 UNION 연산자로만 합치는 나쁜 SQL 문

- **튜닝 전**

```sql
mysql> SELECT 'M' as 성별, 사원번호
    -> FROM 사원
    -> WHERE 성별 = 'M'
    -> AND 성 = 'Baba'
    ->
    -> UNION
    ->
    -> SELECT 'F', 사원번호
    -> FROM 사원
    -> WHERE 성별 = 'F'
    -> AND 성 = 'Baba';
+--------+--------------+
| 성별   | 사원번호     |
+--------+--------------+
| M      |        11937 |
| M      |        12245 |
...
| F      |       498356 |
| F      |       499779 |
+--------+--------------+
226 rows in set (0.01 sec)
```

- UNION한 두 쿼리 모두 I_성별_성 인덱스를 이용
- UNION은 중복 제거 절차를 거치기 때문에 임시 테이블을 생성한다. 조회하는 데이터 수가 많았다면 메모리가 아닌 디스크에 임시 파일을 생성했을 것
- 사원번호는 PK이므로 중복 제거 절차를 거칠 필요가 없음

<br>

- **튜닝 후**

```sql
mysql> SELECT 'M' as 성별, 사원번호
    -> FROM 사원
    -> WHERE 성별 = 'M'
    -> AND 성 = 'Baba'
    ->
    -> UNION ALL
    ->
    -> SELECT 'F', 사원번호
    -> FROM 사원
    -> WHERE 성별 = 'F'
    -> AND 성 = 'Baba';
+--------+--------------+
| 성별   | 사원번호     |
+--------+--------------+
| M      |        11937 |
| M      |        12245 |
...
| F      |       498356 |
| F      |       499779 |
+--------+--------------+
226 rows in set (0.00 sec)
```

- id가 1, 2인 행의 실행 계획까지는 튜닝 전 실행 계획과 동일하지만, 정렬하여 중복을 제거하는 작업이 제외되면서 불필요한 리소스 낭비를 방지한 것

<br>

- **튜닝 후 실행계획**
```
mysql> EXPLAIN SELECT 'M' as 성별, 사원번호 FROM 사원 WHERE 성별 = 'M' AND 성 = 'Baba'  UNION ALL  SELECT 'F', 사원번호 FROM 사원 WHERE 성별 = 'F' AND 성 = 'Baba';
+----+-------------+--------+------------+------+---------------+--------------+---------+-------------+------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys | key          | key_len | ref         | rows | filtered | Extra       |
+----+-------------+--------+------------+------+---------------+--------------+---------+-------------+------+----------+-------------+
|  1 | PRIMARY     | 사원   | NULL       | ref  | I_성별_성     | I_성별_성    | 51      | const,const |  135 |   100.00 | Using index |
|  2 | UNION       | 사원   | NULL       | ref  | I_성별_성     | I_성별_성    | 51      | const,const |   91 |   100.00 | Using index |
+----+-------------+--------+------------+------+---------------+--------------+---------+-------------+------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)
```

<br>

### 4.2.7 인덱스 고려 없이 열을 사용하는 나쁜 SQL문

- **튜닝 전**

```sql
mysql> SELECT 성, 성별, COUNT(1) as 카운트 FROM 사원 GROUP BY 성, 성별;
+--------+--------+-----------+
| 성     | 성별   | 카운트    |
+--------+--------+-----------+
| Aamodt | M      |       120 |
| Acton  | M      |       108 |
...
| Zyda             | F      |        72 |
| Zykh             | F      |        61 |
+------------------+--------+-----------+
3274 rows in set (0.36 sec)
```

<br>

- I_성별_성 인덱스를 사용하여 index full scan을 수행
- I_성별_성 인덱스를 GROUP BY절에서 사용하므로 Using index(커버링 인덱스)로 수행
- 메모리나 디스크에 임시 테이블을 꼭 생성해야할까 고민해봐야함

<br>

- **튜닝 후**

```sql
mysql> SELECT 성, 성별, COUNT(1) as 카운트 FROM 사원 GROUP BY 성별, 성;
+--------+--------+-----------+
| 성     | 성별   | 카운트    |
+--------+--------+-----------+
| Aamodt | M      |       120 |
| Acton  | M      |       108 |
...
| Zyda             | F      |        72 |
| Zykh             | F      |        61 |
+------------------+--------+-----------+
3274 rows in set (0.11 sec)
```

<br>

- 이미 존재하는 I_성별_성 인덱스를 최대한 활용하기 위해 인덱스 순서대로 그루핑함
- 그러면 별도의 임시 테이블을 생성안하고 그루핑과 카운트 연산을 수행할 수 있음

<br>

### 4.2.8 엉뚱한 인덱스를 사용하는 나쁜 SQL문

- **튜닝 전**

```sql
mysql> SELECT 사원번호 FROM 사원 WHERE 입사일자 LIKE '1989%' AND 사원번호 > 100000;
+--------------+
| 사원번호     |
+--------------+
|       100011 |
...
|       499991 |
+--------------+
20001 rows in set (0.16 sec)
```

<br>

- 스토리지 엔진에서 데이터에 접근할 때 사원번호 열로 구성된 기본 키로 액세스하는게 과연 효율적인지 고민해봐야함
- 조건문에서 입사일자 열에 대해 부분검색이 목적인 LIKE 절을 사용한게 최선인지 생각해봐야함

<br>

**튜닝 후**

```sql
mysql> SELECT 사원번호 FROM 사원 WHERE 입사일자 >= '1989-01-01' AND 입사일자 < '1990-01-01' AND 사원번호 > 100000;
+--------------+
| 사원번호     |
+--------------+
|       100526 |
...
|       485464 |
|       495190 |
+--------------+
20001 rows in set (0.13 sec)
```

- LIKE 절보다 부등호 조건절이 우선하여 인덱스를 사용하므로 데이터 접근 범위를 줄일 수 있음

**튜닝 후 실행계획**
```sql
mysql> EXPLAIN SELECT 사원번호 FROM 사원 WHERE 입사일자 >= '1989-01-01' AND 입사일자 < '1990-01-01' AND 사원번호 > 100000;
+----+-------------+--------+------------+-------+------------------------+----------------+---------+------+-------+----------+--------------------------+
| id | select_type | table  | partitions | type  | possible_keys          | key            | key_len | ref  | rows  | filtered | Extra                    |
+----+-------------+--------+------------+-------+------------------------+----------------+---------+------+-------+----------+--------------------------+
|  1 | SIMPLE      | 사원   | NULL       | range | PRIMARY,I_입사일자     | I_입사일자     | 7       | NULL | 49820 |    50.00 | Using where; Using index |
+----+-------------+--------+------------+-------+------------------------+----------------+---------+------+-------+----------+--------------------------+
1 row in set, 1 warning (0.01 sec)
```

- 사원 테이블에서 I_입사일자 인덱스를 활용하여 범위 스캔을 수행
- 테이블에 접근하지 않고 인덱스만 사용하여 결과를 출력 -> 이를 커버링 인덱스 스캔이라고 부름

<br>

### 4.2.9 동등 조건으로 인덱스를 사용하는 나쁜 SQL문

- **튜닝 전**

```sql
mysql> SELECT * FROM 사원출입기록 WHERE 출입문 = 'B';
+--------+--------------+---------------------+-----------------+-----------+--------+
| 순번   | 사원번호     | 입출입시간          | 입출입구분      | 출입문    | 지역   |
+--------+--------------+---------------------+-----------------+-----------+--------+
| 983026 |       110022 | 2020-05-26 11:16:28 | I               | B         | b      |
...
| 1329630 |       299629 | 2020-08-15 02:21:12 | O               | B         | b      |
+---------+--------------+---------------------+-----------------+-----------+--------+
300000 rows in set (0.44 sec)
```

- 실행계획에 따르면 I_출입문 인덱스로 인덱스 스캔을 수행
- 이는 인덱스에 접근한 뒤 테이블에 랜덤 액세스하는 방식이지만, 전체 데이터의 약 50%에 달하는 데이터를 조회하려고 인덱스를 활용하는게 과연 효율적일지 생각해야함

- **튜닝 후**

```sql
mysql> SELECT * FROM 사원출입기록 IGNORE INDEX(I_출입문) WHERE 출입문 = 'B';
+--------+--------------+---------------------+-----------------+-----------+--------+
| 순번   | 사원번호     | 입출입시간          | 입출입구분      | 출입문    | 지역   |
+--------+--------------+---------------------+-----------------+-----------+--------+
| 983026 |       110022 | 2020-05-26 11:16:28 | I               | B         | b      |
...
| 1329630 |       299629 | 2020-08-15 02:21:12 | O               | B         | b      |
+---------+--------------+---------------------+-----------------+-----------+--------+
300000 rows in set (0.34 sec)
```

- 대량의 데이터를 인덱스 스캔으로 조회하는 튜닝 전 쿼리에 대해, 내부 실행되는 인덱스를 무시할 수 있도록 IGNORE INDEX라는 힌트를 사용

<br>

- **튜닝 후 실행계획**
```sql
mysql> EXPLAIN SELECT * FROM 사원출입기록 IGNORE INDEX(I_출입문) WHERE 출입문 = 'B';
+----+-------------+--------------------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table              | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+--------------------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | 사원출입기록       | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 658935 |    10.00 | Using where |
+----+-------------+--------------------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.02 sec)
```

- 테이블 풀 스캔 방식으로 수행됨을 확인 가능

<br>


### 4.2.10 범위 조건으로 인덱스를 사용하는 나쁜 SQL문

- **튜닝 전**

```sql
mysql> SELECT 이름, 성 FROM 사원 WHERE 입사일자 BETWEEN STR_TO_DATE('1994-01-01', '%Y-%m-%d') AND STR_TO_DATE('2000-12-31', '%Y-%m-%d');
+----------+-----------------+
| 이름     | 성              |
+----------+-----------------+
| Kristian | Ghandeharizadeh |
...
| DeForest       | Mullainathan     |
| Sachin         | Tsukuda          |
+----------------+------------------+
48875 rows in set (0.16 sec)
```

- 사원 테이블에서 I_입사일자 인덱스로 범위 스캔을 수행
- Using MRR을 통해 인덱스가 랜덤 액세스가 아닌 순차 스캔으로 최적화하여 처리됨을 확인 가능

- **튜닝 후**

```sql
mysql> SELECT 이름, 성 FROM 사원 WHERE YEAR( 입사일자) BETWEEN '1994' AND '2000';
+--------+----------+
| 이름   | 성       |
+--------+----------+
| Saniya | Kalloufi |
...
| Sachin         | Tsukuda          |
+----------------+------------------+
48875 rows in set (0.11 sec)
```

- **튜닝 후 실행 계획**
```sql
mysql> EXPLAIN SELECT 이름, 성 FROM 사원 WHERE YEAR( 입사일자) BETWEEN '1994' AND '2000';
+----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | 사원   | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 299423 |   100.00 | Using where |
+----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

- 사원 테이블은 테이블 풀 스캔(type: ALL) 방식으로 데이터에 접근함
- 즉, 인덱스 없이 테이블에 직접 접근하며 한 번에 다수의 페이지에 접근하므로 더 효율적으로 수행됨

<br>

## 4.3 테이블 조인 설정 변경으로 착한 쿼리 만들기

### 4.3.1 작은 테이블이 먼저 조인에 참여하는 나쁜 SQL문

- **튜닝 전**

```sql
mysql> SELECT 매핑.사원번호, 부서.부서번호 FROM 부서사원_매핑 매핑, 부서 WHERE 매핑.부서번호 = 부서.부서번호 AND 매핑.시작일자 >= '2002-03-01';
+--------------+--------------+
| 사원번호     | 부서번호     |
+--------------+--------------+
|        11732 | d009         |
...
|       488117 | d007         |
+--------------+--------------+
1341 rows in set (0.47 sec)
```

- 드라이빙 테이블인 부서 테이블과 드리븐 테이블인 부서사원_매핑 테이블간 중첩 루프 조인을 수행.
- 작은 크기의 부서 테이블에서 부서.부서번호 컬럼만 SELECT, WHERE절에 필요하므로 index full scan을 수행.
- 부서번호 컬럼만 사용하도록 인덱스 힌트를 추가하더라도 SQL이 개선되지는 않음
- 부서사원_매핑 테이블은 부서번호 인덱스로 index scan을 수행
- 상대적으로 규모가 큰 테이블의 조건절을 먼저 적용할 수 있다면 조인할 때 비교대상이 줄어들 것

<br>

- **튜닝 후**

```sql
mysql> SELECT STRAIGHT_JOIN 매핑.사원번호, 부서.부서번호 FROM 부서사원_매핑 매핑, 부서 WHERE 매핑.부서번호 = 부서.부서번호 AND 매핑.시작일자 >= '2002-03-01';
+--------------+--------------+
| 사원번호     | 부서번호     |
+--------------+--------------+
|        10298 | d004         |
...
|       499715 | d005         |
+--------------+--------------+
1341 rows in set (0.10 sec)
```

- STRAIGHT_JOIN 힌트를 통해 FROM절에 작성된 테이블 순서대로 조인하도록 고정
- 드라이빙 테이블이 튜닝 전과 반대로 매핑 테이블이 되었으며, 드리븐 테이블이 부서가 됨
- table full scan으로 드라이빙 테이블 데이터를 순차 접근하여 필터링 후 드리븐 테이블에 접근
- 많은 양의 데이터를 랜덤 엑세스 하지 않아 성능이 개선됨
- 즉, 상대적으로 대용량인 부서사원_매핑 테이블을 테이블 풀 스캔으로 처리하고, 부서 테이블에 기본 키로 반복 접근하여 1개의 데이터에만 접근하는 식으로 수행됨

<br>

### 4.3.2 메인 테이블에 계속 의존하는 나쁜 SQL문
- **튜닝 전**

```sql
mysql> SELECT 사원.사원번호, 사원.이름, 사원.성 FROM 사원 WHERE 사원번호 > 450000 AND ( SELECT MAX(연봉) FROM 급여 WHERE 사원번호 = 사원.사원번호 ) > 100000;
+--------------+------------+----------+
| 사원번호     | 이름       | 성       |
+--------------+------------+----------+
|       450025 | Dharmaraja | Marrevee |
...
|       499988 | Bangqing       | Kleiser          |
+--------------+----------------+------------------+
3155 rows in set (0.43 sec)
```

- FROM절 메인 테이블 사원에 접근하여 사원번호 기준으로 index range scan을 수행
- 급여 테이블에 접근하는 서브쿼리는 외부 쿼리에 의존적인 DEPENDANT SUBQUERY 임
- 급여 테이블은 사원번호 PK를 이용함

- 사원번호가 450000을 초과하는 데이터는 49,999건으로 전체 데이터의 15% 수준
- 서브쿼리 대신 조인으로 처리할 수 있는지 확인해봐야 함

- **튜닝 후**

```sql
mysql> SELECT 사원.사원번호, 사원.이름, 사원.성 FROM 사원, 급여 WHERE 사원.사원번호 = 급여.사원번호 AND 사원.사원번호 > 450000 GROUP BY 사원.사원번호 HAVING MAX(급여.연봉) > 100000;
+--------------+------------+----------+
| 사원번호     | 이름       | 성       |
+--------------+------------+----------+
|       450025 | Dharmaraja | Marrevee |
...
|       499988 | Bangqing       | Kleiser          |
+--------------+----------------+------------------+
3155 rows in set (0.19 sec)
```

- WHERE 절의 서브쿼리를 조인으로 변경하면서 GROUP BY 절과 HAVING 절을 이용하여 튜닝 전의 그룹별 최댓값을 계산하도록 개선

- **튜닝 후 실행계획**
```sql
mysql> EXPLAIN SELECT 사원.사원번호, 사원.이름, 사원.성 FROM 사원, 급여 WHERE 사원.사원번호 = 급여.사원번호 AND 사원.사원번호 > 450000 GROUP BY 사원.사원번호 HAVING MAX( 급여.연봉) > 100000;
+----+-------------+--------+------------+-------+-------------------------------------+---------+---------+----------------------------+--------+----------+-------------+
| id | select_type | table  | partitions | type  | possible_keys                       | key     | key_len | ref                        | rows   | filtered | Extra       |
+----+-------------+--------+------------+-------+-------------------------------------+---------+---------+----------------------------+--------+----------+-------------+
|  1 | SIMPLE      | 사원   | NULL       | range | PRIMARY,I_입사일자,I_성별_성        | PRIMARY | 4       | NULL                       | 104330 |   100.00 | Using where |
|  1 | SIMPLE      | 급여   | NULL       | ref   | PRIMARY                             | PRIMARY | 4       | tuning.사원.사원번호       |      9 |   100.00 | NULL        |
+----+-------------+--------+------------+-------+-------------------------------------+---------+---------+----------------------------+--------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)
```

- 드라이빙 테이블은 급여 테이블이고, 드리븐 테이블은 사원 테이블
- 급여 테이블에 먼저 접근하기 위해 옵티마이저가 사원번호 필터링 조건을 `급여.사원번호 > 450000`으로 변경
- DEPENDENT SUBQUERY가 제거되어 쿼리 성능이 개선됨

<br>

### 4.3.3 불필요한 조인을 수행하는 나쁜 SQL문

- **튜닝 전**

```sql
mysql> SELECT COUNT(DISTINCT 사원.사원번호) AS 데이터건수
    -> FROM 사원, (
    -> SELECT 사원번호
    -> FROM 사원출입기록 기록
    -> WHERE 출입문 = 'A'
    -> ) 기록
    -> WHERE 사원.사원번호 = 기록.사원번호;
+-----------------+
| 데이터건수      |
+-----------------+
|          150000 |
+-----------------+
1 row in set (0.46 sec)
```

- 인라인 뷰 조건절에서 인덱스와 상수를 동등 비교하므로 ref const
- 사원 테이블과 조인 조건으로 PK인 사원번호를 이용하므로 eq_ref

<br>

- FROM 절의 인라인 뷰는 사실상 옵티마이저에 의해 조인 방식이 뷰 병합으로 최적화 되어 아래 SQL 처럼 실행됨
- 출입한 사원의 수를 구하는 쿼리는 카운트 할 필요 없이 존재 여부만 확인하면 됨
```sql
SELECT COUNT(DISTINCT 사원.사원번호) AS 데이터건수
FROM 사원, 사원출입기록
WHERE 사원.사원번호 = 사원출입기록.사원번호
AND 출입문 = 'A'
```

<br>

- **튜닝 후**

```sql
mysql> SELECT COUNT(1) AS 데이터건수
    -> FROM 사원
    -> WHERE EXISTS(
    -> SELECT 1
    -> FROM 사원출입기록 기록
    -> WHERE 출입문 = 'A'
    -> AND 기록.사원번호 = 사원.사원번호
    -> );
+-----------------+
| 데이터건수      |
+-----------------+
|          150000 |
+-----------------+
1 row in set (0.28 sec)
```

- 출입 여부만 판단하므로 카운트 할 필요가 없어 EXISTS 구문을 사용
- 출입문 A에 관한 기록이 있는 사원번호에 대해 조인을 한 뒤, 해당하는 데이터만 집계

<br>

- **튜닝 후 실행계획**
```sql
mysql> EXPLAIN SELECT COUNT(1) AS 데이터건수 FROM 사원 WHERE EXISTS( SELECT 1 FROM 사원출입기록 기록 WHERE 출입문 = 'A' AND 기록.사원번호 = 사원.사원번호 );
+----+--------------+-------------+------------+--------+---------------------+---------------------+---------+----------------------------+--------+----------+-------------+
| id | select_type  | table       | partitions | type   | possible_keys       | key                 | key_len | ref                        | rows   | filtered | Extra       |
+----+--------------+-------------+------------+--------+---------------------+---------------------+---------+----------------------------+--------+----------+-------------+
|  1 | SIMPLE       | 사원        | NULL       | index  | PRIMARY             | I_입사일자          | 3       | NULL                       | 299423 |   100.00 | Using index |
|  1 | SIMPLE       | <subquery2> | NULL       | eq_ref | <auto_distinct_key> | <auto_distinct_key> | 4       | tuning.사원.사원번호       |      1 |   100.00 | NULL        |
|  2 | MATERIALIZED | 기록        | NULL       | ref    | I_출입문            | I_출입문            | 4       | const                      | 329467 |   100.00 | Using index |
+----+--------------+-------------+------------+--------+---------------------+---------------------+---------+----------------------------+--------+----------+-------------+
3 rows in set, 2 warnings (0.02 sec)
```
- subquery2는 id가 2인 사원출력기록 테이블
- 사원출입기록 테이블은 EXISTS 연산자로 데이터 존재 여부를 판단하기 위해 임시 테이블을 생성하는 MATERIALIZED로 표기